#!/usr/bin/env python
# -*- coding: utf-8 -*-
# kate: space-indent on; indent-width 4; replace-tabs on;

import sys
import dbus
from time import time
from optparse import OptionParser
from ConfigParser import ConfigParser

parser = OptionParser()

parser.add_option( "-d", "--dbus",
    help="DBus service to connect to.",
    default="org.openattic.systemd"
    )

parser.add_option( "-i", "--interface",
    help="The interface to query.", default=''
    )

options, progargs = parser.parse_args()

protocols = {
    'iSCSI':   ('tcp', 3260),
    'SMB':     ('tcp', 445),
    'SSH':     ('tcp', 22),
    'HTTP':    ('tcp', 80),
    'HTTPS':   ('tcp', 80),
    'FTPCTRL': ('tcp', 21),
    'FTPDATA': ('tcp', 20),
    }

savedstate = ConfigParser()
havestate  = bool( savedstate.read("/var/lib/nagios3/protocol_traffic.%s" % options.interface.lower()) )

nagios = dbus.SystemBus().get_object(options.dbus, "/nagios")
stats = nagios.iptables_get_stats()
exit = 0

def wrapdiff(curr, last):
    """ Calculate the difference between last and curr.

        If last > curr, try to guess the boundary at which the value must have wrapped
        by trying the maximum values of 64, 32 and 16 bit signed and unsigned ints.
    """
    if last <= curr:
        return curr - last

    boundary = None
    for chkbound in (64,63,32,31,16,15):
        if last > 2**chkbound:
            break
        boundary = chkbound
    if boundary is None:
        raise ArithmeticError("Couldn't determine boundary")
    return 2**boundary - last + curr

data = {}
for rule in stats:
    tags = rule["comment"].split(':')
    if not tags or tags[0] != "OPENATTIC":
        continue

    obj = data
    for tag in tags[1:-1]:
        if tag not in obj:
            obj[tag] = {}
        obj = obj[tag]
    obj[tags[-1]] = rule

havedata = ( options.interface.upper() in data and data[ options.interface.upper() ] )

if not havedata or not havestate:
    if not savedstate.has_section("state"):
        savedstate.add_section("state")

    # add rules
    for protocol, (socketproto, portno) in protocols.iteritems():
        if not havedata:
            nagios.iptables_install_rules( options.interface, socketproto, portno, protocol )
            for direction in ("in", "out"):
                sectname = protocol + ':' + direction
                if not savedstate.has_section(sectname):
                    savedstate.add_section(sectname)
                for field in ("bytes", "pkgs"):
                    savedstate.set(sectname, field, 0)

        elif not havestate:
            for direction in ("in", "out"):
                sectname = protocol + ':' + direction
                savedstate.add_section(sectname)
                for key, val in data[ options.interface.upper() ][ protocol.upper() ][ direction.upper() ].iteritems():
                    savedstate.set(sectname, key, val)

    print "Checks for %s have been initialized, please wait until Nagios checks again." % options.interface
    exit = 1

else:
    ifacedata = data[ options.interface.upper() ]
    perfdata  = {}

    dt = time() - savedstate.getfloat("state", "timestamp")

    for protocol, (socketproto, portno) in protocols.iteritems():
        for direction in ("in", "out"):
            for field in ("bytes", "pkgs"):
                perfkey = "_".join( (protocol.lower(), direction, field) )
                sectname = protocol + ':' + direction

                mydata  = ifacedata[ protocol.upper() ][ direction.upper() ]

                dvalue  = wrapdiff(int(mydata[field]), savedstate.getint(sectname, field))
                perfdata[perfkey] = dvalue / dt

                savedstate.set(sectname, field, int(mydata[field]))

    # make sure the order of performance values in the output does never change.
    perfkeys = perfdata.keys()
    perfkeys.sort()

    print "Traffic on %s|%s" % (
        options.interface,
        ' '.join([ "%s=%.2f" % (key, perfdata[key]) for key in perfkeys ])
        )

savedstate.set("state", "timestamp", time())

savedstate.write( open( "/var/lib/nagios3/protocol_traffic.%s" % options.interface, "wb" ) )

sys.exit(exit)
