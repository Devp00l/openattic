#!/usr/bin/env python
# -*- coding: utf-8 -*-
# kate: space-indent on; indent-width 4; replace-tabs on;

import os
import sys
from time import time
from ConfigParser import ConfigParser

disk = os.path.realpath(sys.argv[-1]).replace("/dev/", "")

state = ConfigParser()
havestate = bool( state.read("/var/lib/nagios3/diskstats.%s" % disk) ) and state.has_section("state")

exit = 0

with open("/sys/block/%s/stat" % disk, "rb") as fd:
    currstate = dict(zip((
        "rd_ios", "rd_merges", "rd_sectors", "rd_ticks",
        "wr_ios", "wr_merges", "wr_sectors", "wr_ticks",
        "ios_in_prog", "tot_ticks", "rq_ticks"
      ), [
        int(count) for count in fd.read().split()
    ]))
    currstate["timestamp"] = time()


def wrapdiff(curr, last):
    """ Calculate the difference between last and curr.

        If last > curr, try to guess the boundary at which the value must have wrapped
        by trying the maximum values of 64, 32 and 16 bit signed and unsigned ints.
    """
    if last <= curr:
        return curr - last

    boundary = None
    for chkbound in (64,63,32,31,16,15):
        if last > 2**chkbound:
            break
        boundary = chkbound
    if boundary is None:
        raise ArithmeticError("Couldn't determine boundary")
    return 2**boundary - last + curr


if havestate:
    bytes_per_sector = 512
    interval = float(currstate["timestamp"] - state.getfloat("state", "timestamp"))

    rd_ios = wrapdiff(currstate["rd_ios"], state.getfloat("state", "rd_ios"))
    wr_ios = wrapdiff(currstate["wr_ios"], state.getfloat("state", "wr_ios"))

    rd_ticks = wrapdiff(currstate["rd_ticks"], state.getfloat("state", "rd_ticks"))
    wr_ticks = wrapdiff(currstate["wr_ticks"], state.getfloat("state", "wr_ticks"))

    rd_sectors = wrapdiff(currstate["rd_sectors"], state.getfloat("state", "rd_sectors"))
    wr_sectors = wrapdiff(currstate["wr_sectors"], state.getfloat("state", "wr_sectors"))

    tot_ticks  = wrapdiff(currstate["tot_ticks"], state.getfloat("state", "tot_ticks"))

    rd_iops = rd_ios / interval
    wr_iops = wr_ios / interval

    rd_bps  = rd_sectors / interval * bytes_per_sector
    wr_bps  = wr_sectors / interval * bytes_per_sector

    tot_ios = rd_ios + wr_ios
    tot_iops = tot_ios / interval

    utilization = tot_ticks / interval

    if tot_iops:
        servicetime = utilization / tot_iops
    else:
        servicetime = 0

    if tot_ios:
        tot_avg_wait = (rd_ticks + wr_ticks) / tot_ios
    else:
        tot_avg_wait = 0

    if rd_ios:
        rd_avg_wait = rd_ticks / rd_ios
        rd_avg_size = rd_sectors * bytes_per_sector / 1024. / rd_ios
    else:
        rd_avg_wait = 0
        rd_avg_size = 0

    if wr_ios:
        wr_avg_wait = wr_ticks / wr_ios
        wr_avg_size = wr_sectors * bytes_per_sector / 1024. / wr_ios
    else:
        wr_avg_wait = 0
        wr_avg_size = 0

    util_percent = utilization / 10.

    if util_percent > 75:
        exit = 1
    if util_percent > 85:
        exit = 2

    print  ("Disk load for %(disk)s is at %(util_percent).2f%%.|"
            #"rd_ios=%(rd_ios)d wr_ios=%(wr_ios)d "
            #"rd_ticks=%(rd_ticks)d wr_ticks=%(wr_ticks)d "
            #"rd_sectors=%(rd_sectors)d wr_sectors=%(wr_sectors)d "
            "rd_iops=%(rd_iops).2f wr_iops=%(wr_iops).2f "
            "tot_iops=%(tot_iops).2f "
            "rd_bps=%(rd_bps).2fB/s wr_bps=%(wr_bps).2fB/s "
            "servicetime=%(servicetime).2fms "
            "tot_avg_wait=%(tot_avg_wait).2fms "
            "rd_avg_wait=%(rd_avg_wait).2fms wr_avg_wait=%(wr_avg_wait).2fms "
            "rd_avg_size=%(rd_avg_size).2fB wr_avg_size=%(wr_avg_size).2fB "
            "load_percent=%(util_percent).2f%%;75;85;0;100 ") % {
        "disk":         disk,
        "util_percent": util_percent,
        "rd_ios":       rd_ios,
        "wr_ios":       wr_ios,
        "rd_ticks":     rd_ticks,
        "wr_ticks":     wr_ticks,
        "rd_sectors":   rd_sectors,
        "wr_sectors":   wr_sectors,
        "rd_iops":      rd_iops,
        "wr_iops":      wr_iops,
        "tot_iops":     tot_iops,
        "rd_bps":       rd_bps,
        "wr_bps":       wr_bps,
        "servicetime":  servicetime,
        "rd_avg_wait":  rd_avg_wait,
        "wr_avg_wait":  wr_avg_wait,
        "rd_avg_size":  rd_avg_size,
        "wr_avg_size":  wr_avg_size,
        "tot_avg_wait": tot_avg_wait,
        }
else:
    print "Need state info, please wait until Nagios checks again."
    exit = 1
    state.add_section("state")

for key in currstate:
    state.set("state", key, currstate[key])
state.write( open( "/var/lib/nagios3/diskstats.%s" % disk, "wb" ) )

sys.exit(exit)
